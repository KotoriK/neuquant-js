const t=3*Math.max(499,491,487,503),i={ncycles:100,netsize:256,samplefac:10};class s{constructor(t,s){if(function(t){for(let i=1,s=arguments.length;i<s;i++){const s=arguments[i];if(null!=s)for(const i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}}(this,i,{pixels:t},s),this.netsize<4||this.netsize>256)throw new Error("Color count must be between 4 and 256");if(this.samplefac<1||this.samplefac>30)throw new Error("Sampling factor must be between 1 and 30");this.maxnetpos=this.netsize-1,this.netbiasshift=4,this.intbiasshift=16,this.intbias=1<<this.intbiasshift,this.gammashift=10,this.gamma=1<<this.gammashift,this.betashift=10,this.beta=this.intbias>>this.betashift,this.betagamma=this.beta*this.gamma,this.initrad=this.netsize>>3,this.radiusbiasshift=6,this.radiusbias=1<<this.radiusbiasshift,this.initradius=this.initrad*this.radiusbias,this.radiusdec=30,this.alphabiasshift=10,this.initalpha=1<<this.alphabiasshift,this.radbiasshift=8,this.radbias=1<<this.radbiasshift,this.alpharadbshift=this.alphabiasshift+this.radbiasshift,this.alpharadbias=1<<this.alpharadbshift,this.network=[],this.netindex=new Uint32Array(256),this.bias=new Uint32Array(this.netsize),this.freq=new Uint32Array(this.netsize),this.radpower=new Uint32Array(this.netsize>>3);for(let t=0,i=this.netsize;t<i;t++){let i=(t<<this.netbiasshift+8)/this.netsize;this.network[t]=new Float64Array([i,i,i,0]),this.freq[t]=this.intbias/this.netsize,this.bias[t]=0}}unbiasnet(){for(let t=0,i=this.netsize;t<i;t++)this.network[t][0]>>=this.netbiasshift,this.network[t][1]>>=this.netbiasshift,this.network[t][2]>>=this.netbiasshift,this.network[t][3]=t}altersingle(t,i,s,h,e){this.network[i][0]-=t*(this.network[i][0]-s)/this.initalpha,this.network[i][1]-=t*(this.network[i][1]-h)/this.initalpha,this.network[i][2]-=t*(this.network[i][2]-e)/this.initalpha}alterneigh(t,i,s,h,e){const a=Math.abs(i-t),n=Math.min(i+t,this.netsize);let r=i+1,o=i-1,l=1;for(;r<n||o>a;){const t=this.radpower[l++];if(r<n){const i=this.network[r++];i[0]-=t*(i[0]-s)/this.alpharadbias,i[1]-=t*(i[1]-h)/this.alpharadbias,i[2]-=t*(i[2]-e)/this.alpharadbias}if(o>a){const i=this.network[o--];i[0]-=t*(i[0]-s)/this.alpharadbias,i[1]-=t*(i[1]-h)/this.alpharadbias,i[2]-=t*(i[2]-e)/this.alpharadbias}}}contest(t,i,s){let h=~(1<<31),e=h,a=-1,n=a;for(let r=0,o=this.netsize;r<o;r++){let o=this.network[r],l=Math.abs(o[0]-t)+Math.abs(o[1]-i)+Math.abs(o[2]-s);l<h&&(h=l,a=r);let f=l-(this.bias[r]>>this.intbiasshift-this.netbiasshift);f<e&&(e=f,n=r);let b=this.freq[r]>>this.betashift;this.freq[r]-=b,this.bias[r]+=b<<this.gammashift}return this.freq[a]+=this.beta,this.bias[a]-=this.betagamma,n}inxbuild(){let t=0,i=0;for(let s=0,h=this.netsize;s<h;s++){let e=this.network[s],a=null,n=s,r=e[1];for(let t=s+1;t<h;t++)a=this.network[t],a[1]<r&&(n=t,r=a[1]);if(a=this.network[n],s!==n&&([e[0],a[0]]=[a[0],e[0]],[e[1],a[1]]=[a[1],e[1]],[e[2],a[2]]=[a[2],e[2]],[e[3],a[3]]=[a[3],e[3]]),r!==t){this.netindex[t]=i+s>>1;for(let i=t+1;i<r;i++)this.netindex[i]=s;t=r,i=s}}this.netindex[t]=i+this.maxnetpos>>1;for(let i=t+1;i<256;i++)this.netindex[i]=this.maxnetpos}learn(){const i=this.pixels.length,s=30+(this.samplefac-1)/3,h=i/(3*this.samplefac);let e,a=h/this.ncycles|0,n=this.initalpha,r=this.initradius,o=r>>this.radiusbiasshift;o<=1&&(o=0);for(let t=0;t<o;t++)this.radpower[t]=n*((o*o-t*t)*this.radbias/(o*o));i<t?(this.samplefac=1,e=3):e=i%499!=0?1497:i%491!=0?1473:i%487!=0?1461:1509;let l=0;for(let t=0;t<h;){let h=(255&this.pixels[l])<<this.netbiasshift,f=(255&this.pixels[l+1])<<this.netbiasshift,b=(255&this.pixels[l+2])<<this.netbiasshift,d=this.contest(h,f,b);if(this.altersingle(n,d,h,f,b),0!==o&&this.alterneigh(o,d,h,f,b),l+=e,l>=i&&(l-=i),0===a&&(a=1),++t%a==0){n-=n/s,r-=r/this.radiusdec,o=r>>this.radiusbiasshift,o<=1&&(o=0);for(let t=0;t<o;t++)this.radpower[t]=n*((o*o-t*t)*this.radbias/(o*o))}}}buildColorMap(){this.learn(),this.unbiasnet(),this.inxbuild()}getColorMap(){const t=new Buffer(3*this.netsize),i=new Buffer(this.netsize);for(let t=0,s=this.netsize;t<s;t++)i[this.network[t][3]]=t;for(let s=0,h=0,e=0,a=this.netsize;s<a;s++)e=i[s],t[h++]=255&this.network[e][0],t[h++]=255&this.network[e][1],t[h++]=255&this.network[e][2];return t}}function h(t,i,s,h){let e=0,a=16777216;for(let n=0,r=t.length;n<r;){const r=i-t[n++],o=s-t[n++],l=h-t[n],f=r*r+o*o+l*l,b=n/3|0;f<a&&(a=f,e=b),n++}return e}function e(t,i){const h=new s(t,i);return h.buildColorMap(),h.getColorMap()}function a(t,i){const s=new Buffer(t.length/3),e={};for(let a=0,n=0,r=t.length;a<r;){const r=t[a++],o=t[a++],l=t[a++],f=r<<16|o<<8|l;s[n++]=f in e?e[f]:e[f]=h(i,r,o,l)}return s}function n(t,i){const s=e(t,i);return{palette:s,indexed:a(t,s)}}export{a as indexed,e as palette,n as quantize};
//# sourceMappingURL=index.modern.js.map
